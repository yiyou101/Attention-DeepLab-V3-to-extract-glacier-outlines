import torch
from osgeo import gdal
import numpy as np
import glob
import math
import segmentation_models_pytorch as smp
import cv2

train_length = 1024

def readTif(fileName):
    dataset = gdal.Open(fileName)
    if dataset == None:
        print(fileName + "文件无法打开")
    #  栅格矩阵的列数
    width = dataset.RasterXSize
    #  栅格矩阵的行数
    height = dataset.RasterYSize
    #  获取数据
    data = dataset.ReadAsArray(0, 0, width, height)
    #获取地理信息
    geotans = dataset.GetGeoTransform()
    #获取投影
    proj = dataset.GetProjection()
    return data, geotans, proj

def writeTiff(im_data, im_geotrans, im_proj, path):
    if 'int8' in im_data.dtype.name:
        datatype = gdal.GDT_Byte
    elif 'int16' in im_data.dtype.name:
        datatype = gdal.GDT_UInt16
    else:
        datatype = gdal.GDT_Float32
    if len(im_data.shape) == 3:
        im_bands, im_height, im_width = im_data.shape
    elif len(im_data.shape) == 2:
        im_data = np.array([im_data])
        im_bands,im_height, im_width =im_data.shape
    # 创建文件
    driver = gdal.GetDriverByName("GTiff")
    dataset = driver.Create(path, int(im_width), int(im_height), int(im_bands), datatype)
    if (dataset != None):
        dataset.SetGeoTransform(im_geotrans)  # 写入仿射变换参数
        dataset.SetProjection(im_proj)  # 写入投影
    for i in range(im_bands):
        dataset.GetRasterBand(i + 1).WriteArray(im_data[i])
    del dataset

#模型语义分割
def predict(Model_Path, img_nor):
    device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
    model = smp.DeepLabV3Plus(encoder_name='resnet34', in_channels=4, classes=1)
    model.to(device)
    model.load_state_dict(torch.load(Model_Path))
    Pred_list = []
    #a = 0
    model.eval()
    for i in img_nor:
        with torch.no_grad():
            im_data = np.array(i)
            #   图像水平翻转
            im_data_hor = np.flip(i, axis=2)  # 数据是3维
            #  图像垂直翻转
            im_data_vec = np.flip(i, axis=1)
            #  图像对角镜像
            im_data_dia = np.flip(im_data_vec, axis=2)
            # 图片顺时针旋转90°
            im_data_rotz = np.rot90(i, -1, (1, 2))
            # 图片逆时针旋转90°
            im_data_rotn = np.rot90(i, 1, (1, 2))
            img = np.array([im_data,im_data_hor,im_data_vec,im_data_dia,im_data_rotz,im_data_rotn])
            print(img.shape)
            preds = []
            for j in img:
                img_tensor = torch.from_numpy(np.array([j]))
                # 将tensor拷贝到device中，只用cpu就是拷贝到cpu中，用cuda就是拷贝到cuda中。
                img_tensor = img_tensor.to(device=device)
                pred = model(img_tensor)
                # 提取结果
                if class_style == 'two_class':
                    pred = torch.sigmoid(pred)
                    #获取onehot类别下标，就可以得出所分出的是哪个类
                    print(pred.shape)
                    #将四维将为二维
                    pred = np.array(pred.data.cpu()[0])[0]
                else:
                    pred = pred[0]
                    pred = torch.softmax(pred, dim=0).cpu()
                    _, pred = torch.max(pred, dim=0)
                    print(pred.shape)
                    pred = np.array(pred)
                preds.append(pred)
                #savepath = 'G:/DL/list2/' + str(a) + '.tif'
                #a = a + 1
                #writeTiff(pred, img_trans, img_proj, savepath)
            # 还原
            preds = np.array(preds)
            print(preds.shape)
            preds[1] = np.flip(preds[1], axis=1)
            preds[2] = np.flip(preds[2], axis=0)
            preds[3] = np.flip(np.flip(preds[3], axis=0), axis=1)
            preds[4] = np.rot90(preds[4], 1, (0, 1))
            preds[5] = np.rot90(preds[5], -1, (0, 1))
            pred = (preds[0]+preds[1]+preds[2]+preds[3]+preds[4]+preds[5])/6
            print(pred.shape)
        Pred_list.append(pred)
        print('finish')
    return Pred_list

#预处理
def processing(im_data,ClipLength, Model_Path):
    # 剪裁影像
    clip_list, row_sum, col_sum, re_row, re_col = clipTiff(im_data, ClipLength)
    print(row_sum, col_sum)
    # 对数据进行归一化处理
    img_normalization = normalization_generator(clip_list)
    # 进行预测
    pred_list = predict(Model_Path, img_normalization)
    result_shape = (im_data.shape[1], im_data.shape[2])
    # 拼接影像
    result = mosicTiff(pred_list, row_sum, col_sum, re_row, re_col, result_shape, ClipLength)
    return result



model_path = r'H:\DL\GF6-model\best_model'
img_list = glob.glob(r"H:\DL\模型测试\GF6_PMS_E91.9_N32.8_20200819\GF6_PMS_E91.9_N32.8_20200819_L1A1120027898-测试区间.tif")
class_style = 'two_class'

#剪裁所占面积r,相邻影像重叠面积为1-r^1/2,剪裁边长为(1-r^1/2)*训练样本边长/2
in_area = 0.9
clipLength = int((1 - math.sqrt(in_area)) * train_length / 2)
img_data, img_trans, img_proj = readTif(img_list[0])
data_result = processing(img_data , clipLength, model_path)
savepath = r'H:\DL\模型测试\test\result2.tif'
writeTiff(data_result, img_trans, img_proj, savepath)
